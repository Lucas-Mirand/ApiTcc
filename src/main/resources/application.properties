# ===============================================
# CONFIGURAÇÃO GERAL DA APLICAÇÃO
# ===============================================
# Nome da Aplicação
spring.application.name=apitcc

# Perfil Ativo (prod para produção, dev para desenvolvimento)
# Este valor é lido do arquivo .env (SPRING_PROFILES_ACTIVE)
spring.profiles.active=${SPRING_PROFILES_ACTIVE:prod}


# ===============================================
# CONFIGURAÇÃO DO BANCO DE DADOS (DataSource)
# ===============================================
# Os valores abaixo são lidos diretamente do seu arquivo .env
spring.datasource.url=${DATABASE_URL}
spring.datasource.username=${DATABASE_USERNAME}
spring.datasource.password=${DATABASE_PASSWORD}
spring.datasource.driver-class-name=org.postgresql.Driver


# ===============================================
# CONFIGURAÇÃO DO JPA E HIBERNATE
# ===============================================
# Dialeto específico para o PostgreSQL, permite que o Hibernate gere o SQL correto.
spring.jpa.properties.hibernate.dialect=org.hibernate.dialect.PostgreSQLDialect

# Ação a ser executada na inicialização.
# 'update': atualiza o schema do banco (bom para desenvolvimento, cria/altera tabelas se necessário).
# 'validate': valida se as tabelas correspondem às entidades, mas não altera nada.
# 'none': não faz nada (recomendado para produção quando se usa uma ferramenta de migration).
spring.jpa.hibernate.ddl-auto=update

# Exibe o SQL gerado pelo Hibernate no console (ótimo para depurar).
spring.jpa.show-sql=true

# Formata o SQL exibido para ser mais fácil de ler.
spring.jpa.properties.hibernate.format_sql=true

# ESTRATÉGIA DE NOMEAÇÃO FÍSICA (A CORREÇÃO PRINCIPAL)
# Isso resolve o problema de 'areaAtuacao' (Java) vs 'area_atuacao' (SQL).
# O Spring irá converter nomes em camelCase (Java) para snake_case (SQL) automaticamente.
#spring.jpa.hibernate.naming.physical-strategy=org.springframework.boot.orm.jpa.hibernate.SpringPhysicalNamingStrategy